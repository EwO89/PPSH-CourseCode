## Задача 1

У вас есть класс ﻿`Employee`, который представляет сотрудника организации:

```python
class Employee:
    def __init__(self, name, employee_id, position, mail):
        self.name = name
        self.employee_id = employee_id
        self.position = position
        self.mail = mail

    def display_info(self):
        print(f"Name: {self.name}")
        print(f"Employee ID: {self.employee_id}")
        print(f"Position: {self.position}")
        print(f"Mail: {self.mail}")

    def generate_email(self):
        email = f"{self.name.lower().replace(' ', '.')}.{self.employee_id}@company.com"
        return email

    def send_email(self, recipient, subject, message):
        print(f"Sending email to {recipient}:\nSubject: {subject}\nMessage: {message}")

```

Какому принципу противорчит данный код?

<details><summary>Ответ (нажмите на стрелочку)</summary>
<p>
Данный код противрочит принципу единственной ответственности
(Single responsibility principle)
</p>
<p>
В этом примере класс <code>﻿Employe</code> имеет несколько методов,
которые относятся к разным ответственностям: ﻿<code>display_info</code>
отображает информацию о сотруднике, ﻿<code>generate_email</code>
генерирует электронную почту сотрудника, <code>﻿send_email</code>
отправляет электронную почту.
</p>
<p>
Такой подход не соответствует принципу единственной ответственности, так 
как класс ﻿<code>Employee</code> выполняет сразу несколько различных
функций. Это делает класс менее модульным и сложным для поддержки и
тестирования.
</p>
</details>

<details><summary>Подсказка (смотрите только если нет идей)</summary>
<p>
Разделите функциональность класса <code>Employee</code> таким образом, чтобы код соответствовал SRP. Например это можно сделать, разделив <code>Employee</code> на два класса <code>EmployeeInfo</code> и <code>EmployeeMail</code>.
</details>

## Задача 2

У вас есть магазин одежды. Вы даете скидку 20% для ваших любимых покупателей используя класс `Discount`:

```python
class Discount:
  def __init__(self, customer, price):
      self.customer = customer
      self.price = price
  
  def give_discount(self):
      if self.customer == 'FAV':
          return self.price * 0.2
```

Вдруг, вы решаете добавить скидку 40% для VIP клиентов. Каким образом вы это сделаете?

<details><summary>Подсказка (смотрите только если нет идей)</summary>
<p>
Вы не можете добавить еще один <code>if</code> в метод <code>give_discount</code>, поскольку данное действие будет считаться за модификацию класса, а это в свою очередь противоречит принципу открытости-закрытости.
</p>
</details>

<details><summary>Ответ (нажмите на стрелочку)</summary>
<p>
Добавьте новый класс, который будет расширять <code>Discount</code>. В новом классе реализуйте логику добавления скидки.
</p>
</details>

## Задача 3

Создайте класс ﻿`Shape` с методом `﻿area()`, который возвращает площадь фигуры.

Создайте подкласс ﻿`Rectangle`, который наследует класс `﻿Shape`. В конструкторе класса `﻿Rectangle` должны быть аргументы, задающие ширину и высоту прямоугольника. Метод `﻿area()` класса `﻿Rectangle` должен возвращать площадь прямоугольника.

Создайте подкласс `﻿Square`, который наследует класс `﻿Shape`. В конструкторе класса `﻿Square` должен быть аргумент, задающий длину стороны квадрата. Метод `﻿area()` класса `﻿Square` должен возвращать площадь квадрата.

Напишите функцию ﻿`calculate_total_area()`, которая принимает список объектов класса ﻿`Shape` и возвращает общую площадь всех объектов в списке.

> Объекты подклассов должны быть взаимозаменяемыми с объектами родительского класса. То есть, в любом месте программы, где ожидается объект, который наследуется от `Shape`, должна быть возможность передать объект класса `﻿Rectangle` или ﻿`Square`, и программа должна работать корректно.

### Пример использования:

```python
rectangle = Rectangle(4, 5)
square = Square(3)
print(calculate_total_area([rectangle, square]))
```

## Задача 4

Создайте класс ﻿`Bird`, который представляет птицу. У птицы есть методы `﻿walk()`, `swim()` и `fly()`.

Создайте класс ﻿`Crow`, который наследуется от `Bird` и представляет ворону. Ворона может ходить и летать, но не может плавать.

Создайте класс ﻿`Penguin`, который также наследуется от `Bird` и представляет пингвина. Пингвин умеет ходить и плавать, но не умеет летать.

> Классы не должны зависеть от методов, которые они не используют. Поэтому необходимо изменить структуру классов таким образом, чтобы они не нарушали принцип разделения интерфейсов.

## Задача 5

Вы разрабатываете систему для управления умным домом. У вас есть различные устройства, такие как лампы, датчики движения и термостаты. Каждое устройство реализует интерфейс ﻿`Device` со следующими методами: `turn_on()` включает устройство; `﻿turn_off()` выключает устройство.

У вас также есть класс `﻿SmartHome`, который управляет всеми устройствами. В начале работы системы все устройства выключены. ﻿`SmartHome` должен предоставлять методы для включения и выключения всех устройств в доме.

Ваша задача состоит в том, чтобы реализовать эту систему таким образом, чтобы `﻿SmartHome` зависил только от абстракции (интерфейса `﻿Device`), а не от конкретных реализаций устройств (например, лампы или датчика движения).

### Пример использования:

```python
# Создаем экземпляры устройств
lamp = Lamp()
motion_sensor = MotionSensor()
thermostat = Thermostat()

# Создаем экземпляр умного дома и передаем ему список устройств
smart_home = SmartHome([lamp, motion_sensor, thermostat])

# Включаем все устройства
smart_home.turn_on()
# Вывод:
# Lamp turned on
# Motion sensor turned on
# Thermostat turned on

# Выключаем все устройства
smart_home.turn_off()
# Lamp turned off
# Motion sensor turned off
# Thermostat turned off
```

## Задача 6

Представьте, что вы разрабатываете систему для управления банковскими счетами. У вас есть следующие классы:

- Класс ﻿`Account` — представляет банковский счет с основными методами, такими как ﻿`deposit` (внести деньги на счет), `﻿withdraw` (снять деньги со счета) и `﻿get_balance` (получить баланс).
- Класс ﻿`SavingsAccount` — наследуется от класса ﻿`Account` и имеет дополнительные методы, такие как `﻿calculate_interest` (рассчитать проценты по счету) и `﻿get_interest_rate` (получить процентную ставку).
- Класс ﻿`CheckingAccount` — также наследуется от класса ﻿`Account` и имеет дополнительные методы, такие как ﻿`deduct_fees` (вычесть комиссию) и ﻿`get_fee_percentage` (получить процент комиссии).
- Класс `﻿Bank` — представляет банк и содержит список счетов. Он имеет методы для добавления нового счета, удаления счета и поиска счета по номеру.

Добавьте новую функциональность в систему управления банковскими счетами — возможность перевода денег со счета на счет. Для этого вам нужно изменить существующую архитектуру:

- Расширьте класс ﻿`Account` новым методом `transfer`. Метод должен переводить сумму с текущего счета на счет-назначение. Если средств недостаточно, должно быть выброшено исключение.
- Создайте новый интерфейс, который будет определять метод ﻿`transfer`. Класс ﻿`Account` должен реализовывать этот интерфейс.
- Создайте новый класс, который будет отвечать за выполнение операций перевода между счетами.
- Обновите класс ﻿`Bank`, чтобы он использовал новые классы для выполнения операций перевода.

Реализуйте эти классы, соблюдая принципы SOLID. Обеспечьте, чтобы каждый класс выполнял только одну ответственность, был открыт для расширения, но закрыт для модификации, мог замениться на свои подклассы без нарушения функциональности, использовал только необходимые интерфейсы и зависел от абстракций, а не от конкретных реализаций. Вся система должна быть гибкой и легко расширяемой, чтобы в будущем можно было добавить новые типы счетов или функциональности без изменения существующего кода.

### Пример использования:

```python
# Создаем экземпляры счетов
savings_account = SavingsAccount(account_number="SAV-001", balance=1000, interest_rate=5)
checking_account = CheckingAccount(account_number="CHK-001", balance=500, fee_percentage=2)

# Создаем экземпляр банка и добавляем счета
bank = Bank()
bank.add_account(savings_account)
bank.add_account(checking_account)

# Выводим балансы счетов
print("Savings Account Balance:", savings_account.get_balance())
print("Checking Account Balance:", checking_account.get_balance())
# Savings Account Balance: 1000
# Checking Account Balance: 500

# Переводим деньги со счета-источника на счет-назначение
bank.transfer_funds(source_account_number="SAV-001", destination_account_number="CHK-001", amount=500)

# Выводим обновленные балансы счетов
print("Savings Account Balance:", savings_account.get_balance())
print("Checking Account Balance:", checking_account.get_balance())
# Savings Account Balance: 500
# Checking Account Balance: 1000
```

